---
title: "要件定義、基本設計、詳細設計の流れを総復習"
source: "https://zenn.dev/nyanchu/articles/27a3f95d98df45"
author:
  - "[[Zenn]]"
published: 
created: 2025-09-03
description: ""
tags: ["clippings", "個人開発", "プロダクト", "マーケティング"]
image: "assets/og-base-w1200-v2.png"
---
はじめに 📘
------

この記事は [ラクス Advent Calendar 2023](https://qiita.com/advent-calendar/2023/rakus) の7日目の記事になります。

要件定義から基本設計、さらに実装や保守運用に至るまでの一貫した経験を何度か積んできましたが、毎回  
「要件定義って具体的に何の項目が必要だっけ？」  
「基本設計との違いって何だったっけ？」  
「基本設計と詳細設計の区別って？」  
といった疑問が頭をよぎってきました。  
そんなわけで、これまでの経験を振り返りつつ、開発プロセスについて１からまとめていくことで頭の中の大掃除を行なっていきたいと思います🧹

この記事の対象者 🎯
----------

* 開発プロセスについて学びたい方
* 要件定義の基本を学びたい人
* 要件定義と基本設計の違いがわからない人
* 一緒に開発プロセスについて復習したい方

前提
--

* 記事中の一部（特に要件定義や基本設計、詳細設計のサンプル）を自動生成で作成してます。一貫性の無い内容があるかも知れませんが、あくまでサンプルとして参照ください。
* 各プロジェクトの性質や目的、チームの動き方によって、最適なアプローチは異なります。したがって、この記事のプロセスや手法は一つの例として参考にしてください。

システム開発のプロセス ♻️
--------------

システム開発は一般的に下記のフェーズで進んでいきます。

プロジェクト関係者を把握 👨‍👩‍👦‍👦
--------------------

要件定義は、**自社開発**と**受託開発**では大きく異なるプロセスを取ります。

一般的に、受託開発では**より厳密なドキュメント化と成果物**の提出が求められます。

### 自社開発

* **関係性**：

  + 開発チームは通常、企業の内部ステークホルダー（例: マーケティング部門、運営チーム、デザイナーなど）と直接コミュニケーションを取ります。ただし、プロジェクトによっては営業担当者が仲介することもあります。
* **要件定義の特徴**：

  + 要件には柔軟性が必要です。ビジネスの目標に対応して変動する可能性が高いためです。
  + ドキュメントはプロジェクトの進行とともに追記され、最終的には詳細なものになる傾向があります。

### 受託開発

* **関係性**：

  + 開発チームはクライアントとの間でフォーマルなコミュニケーションを行います。
* **要件定義の特徴**：

  + 要件は契約に基づいて正式に文書化され、プロジェクトの範囲が明確に定義されます。
  + 自社開発と比較して柔軟性は低いですが、アジャイル開発手法を採用することで柔軟性を求められるケースがあります。
  + クライアントとのコミュニケーションは、ミーティングやドキュメント交換を通じて慎重に行われます。

要件定義と基本設計の違い
------------

**要件定義**は、**「Why」と「What」** に焦点を当てたプロセスです。  
これは、開発するシステムやソフトウェアが満たすべき機能や要求を明確にします。  
一方、**基本設計** は、**「How」** の段階です。  
要件定義で特定された要求をどのように具体的なシステム設計で実現するかを決定します。

* **Why（要件定義）**：

  + 達成したい目標や解決すべき問題は何か？
  + 目標達成のために何が必要か、現在の課題は何か？
* **What（要件定義）**：

  + これらの課題を解決するために必要な機能は何か？
    - 機能要件（システムが実行すべきタスクや機能）
    - 非機能要件（パフォーマンス、セキュリティ、可用性など）
* **How（基本設計）**：

  + 上記の要件をどのようなシステム構成で解決するか？
    - **画面設計（UI/UX設計）**
      * ユーザーとのインタラクションをどう設計するか、画面遷移図などを含む。
    - **機能設計**
      * システムが具体的にどのように機能するか、API設計、ユースケース図、フローチャート図を用いて構想する。
    - **データ設計**
      * システムが使用するデータの構造、ER図でデータベースの設計を行う。

要件定義　📜
------

### なぜ要件定義が必要なのか？ 🤔

* **明確な目標の設定**
  + プロジェクトの目的やゴールをはっきりさせることで、開発範囲の拡大を防ぎます。
* **期待の調整**
  + 関係者間の期待値を一致させ、プロジェクトの成果物に対する共通の理解を確立します。
* **リスクの軽減**
  + プロジェクトに潜在するリスクを早期に特定し、適切な対応策を講じることができます。

特にクライアントとエンジニアの間の **認識ズレを解消** することが重要だと考えてます。

*認識ズレの例* 🚨

|  | エンジニア | ビジネス/クライアント |
| --- | --- | --- |
| 要望 | 最初に決めた要件に沿って開発 | 要件は変更される可能性がある |
| 期限 | 品質を保ちながらの適切なスケジュール | 品質を保ちつつできるだけ早く提供 |
| コスト | 適切な品質を維持するために必要なコストを見積もる | 限られた予算内で高品質の製品やサービスを期待 |
| 技術 | 新しい技術の採用を模索 | リスクを最小限に抑えるための既存技術の利用 |

### 機能要件と非機能要件の違い

#### 機能要件

システムや製品が具体的に提供する機能や動作。

* **ユーザー登録**：ユーザーがアカウントを作成できる機能。
* **データ検索**：キーワードに基づく情報検索。
* **レポート生成**：特定のデータをもとにしたレポート作成。
* **オンライン決済**：製品やサービスのオンライン購入。
* **メール通知**：自動的なメール送信機能。

#### 非機能要件

システムが「どのように動作すべきか」を定める品質属性。

* **パフォーマンス**：3秒以内の応答時間。
* **可用性**：年間99.9%の稼働率。
* **セキュリティ**：データの暗号化、監理ログの保管。
* **スケーラビリティ**：同時に数千人のユーザー対応。
* **ユーザビリティ**：直感的なインターフェース。
* **運用・保守性**：運用時間帯、メンテナンスのダウンタイム。

要件定義の流れ
-------

### 1.プロジェクトのスコープと目的の明確化

プロジェクトの全体的な目標、範囲、制約を定義するために、プロジェクト憲章またはスコープステートメントを作成します。

* Tips📝:
  + プロジェクトに含まれないこと（やらないこと）も明確にする。
  + 利用可能なリソース（人的、金銭的リソース）を把握する。
  + 目標はSMART（具体的、測定可能、達成可能、現実的、期限設定）の法則に従う。

プロジェクト憲章(架空のサンプル)

**プロジェクト名**：社内コミュニケーションポータル開発

**プロジェクトマネージャー**：田中 太郎

**最終更新日**：2023年5月1日

**プロジェクトの目的・背景**：  
社内の異なる部門間でのコミュニケーションとコラボレーションを強化するための統合コミュニケーションポータルを開発する。現在、社内の情報共有は電子メールや複数の別々のツールを介して行われており、情報の断片化が課題となっている。

**プロジェクトの目標**：

* 統合されたメッセージングとファイル共有機能を持つポータルの開発。
* ユーザーごとのカスタマイズ可能なダッシュボードの提供。
* 2023年12月までに社内での実装と運用開始。

**プロジェクトのスコープ**：

* ユーザー認証システムの設計と実装。
* リアルタイムメッセージング機能の開発。
* ドキュメント共有と管理機能の統合。

**やること**：

* ユーザーインターフェースの設計。
* バックエンドのAPI開発。
* データセキュリティとプライバシー保護のための措置の実装。

**やらないこと**：

* 既存の社外向けコミュニケーションツールの統合。
* 高度なビデオ会議システムの統合。
* 顧客向け機能の開発。

**リソース**：

* 社内開発チーム（5人のエンジニア、2人のデザイナー）。
* IT部門からの技術支援。
* 予算：1000万円。

**ステークホルダー**：

* IT部門マネージャー（技術的な要件とサポートに関して）。
* 各部門のマネージャー（ユーザー要件とフィードバックに関して）。
* 社内セキュリティチーム（データセキュリティとコンプライアンスに関して）。

### 2.ステークホルダーの識別と関与

プロジェクトに影響を与える全ての関係者を特定し、彼らのニーズと期待を理解します。

ステークホルダーリスト(架空のサンプル)

| ステークホルダー名 | 役割 | 部署/組織 | 影響度 | 利害関係 | 主要な関心事 | コミュニケーション方法 | ノート |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 例：田中 太郎 | プロジェクトマネージャー | 開発部 | 高 | 直接的な影響 | 納期と品質の管理 | 週次ミーティング |  |
| 例：佐藤 花子 | 営業代表 | 営業部 | 中 | 間接的な影響 | 顧客満足度の向上 | メールアップデート |  |

### 3.要望の調査

エンドユーザーへのヒアリング、インタビュー、アンケートなどを通じて要望を収集します。

案件などによって営業が介在するケースがありますが、できる限りエンジニアもエンドユーザーから直接話を聞く機会を作ることが望ましいと思います。  
ドキュメントなど何かしらが仲介した情報と直接話を聞く情報では情報量にかなりの差があると思います。

### 4.要求の細分化

収集した要求を明確化し、優先順位をつけながら、実現可能な内容を整理します。

* Tips📝:
  + すべてのユーザー要求が現実的であるとは限らないため、技術的な観点から代替案を提案することが重要だと考えてます。これにより、実現可能な解決策を模索するとともに、**エンジニアとしての付加価値** を提供することができます。

機能一覧(架空のサンプル)

| カテゴリー | 必須/希望 | 優先度 | 機能概要 | 要求内容 |
| --- | --- | --- | --- | --- |
| ユーザー管理 | 必須 | 高 | アカウント作成 | ユーザーは自分のアカウントを作成できる必要がある。 |
| 決済システム | 必須 | 中 | オンライン決済 | ユーザーはオンラインで商品の支払いができる。 |
| 商品管理 | 希望 | 低 | 商品登録 | 管理者は新しい商品をシステムに登録できる。 |
| レポート機能 | 希望 | 低 | 売上レポート | 管理者は月間の売上レポートを閲覧できる。 |

### 5.要件のドキュメント化

収集した情報を整理し、要件文書にまとめます。この段階で機能要件と非機能要件を区別します。

要件定義案(架空のサンプル)

**プロジェクト概要**

このプロジェクトは、社内コミュニケーションとコラボレーションを改善するための統合ポータルを開発することを目的としています。ポータルは、メッセージング、ファイル共有、プロジェクト管理ツールを提供し、社員が効率的に情報を共有し、協力して作業できる環境を作り出します。

**現状の課題、背景**

現在、社内の情報共有はメール、別々のチャットツール、物理的なドキュメントを通じて行われており、重要な情報が分散し、見落とされることが頻繁にあります。また、部門間のコミュニケーションが不十分で、プロジェクトの進行に障害が生じています。

**目的・目標**

目的  
社内のコミュニケーションとコラボレーションを効率化し、業務の生産性を向上させる。

目標  
統合コミュニケーションポータルの開発と導入：

2024年末までに、社内全員が利用できる統合コミュニケーションポータルを開発し、実装する。  
ユーザーエンゲージメントの向上：

導入後3ヶ月以内に、社内の80%以上の従業員がポータルをアクティブに利用する。  
情報共有の効率化：

導入後6ヶ月以内に、内部メール使用量を50%削減する。  
社内のプロジェクト管理に関する問い合わせ時間を40%短縮する。  
ユーザーフィードバックに基づく改善：

導入後の最初の3ヶ月でユーザーフィードバックを収集し、ユーザビリティの改善点を特定する。  
導入後6ヶ月以内にユーザビリティの改善を実施し、ユーザー満足度を90%以上に達成する。

**現状の課題と目標のギャップ**

現在の社内コミュニケーションの方法は時間がかかり、非効率的であるため、情報が適切に共有されないことがあります。このプロジェクトの目標は、これらの課題を解消し、全社員が容易にアクセスし、情報を共有できる一元化されたプラットフォームを提供することです。このギャップを埋めることにより、社内の生産性と協力が向上することが期待されます。

**機能一覧**

| カテゴリー | 必須/希望 | 優先度 | 機能概要 | 要求内容 |
| --- | --- | --- | --- | --- |
| ユーザー管理 | 必須 | 高 | アカウント作成 | ユーザーは自分のアカウントを作成できる必要がある。 |
| 決済システム | 必須 | 中 | オンライン決済 | ユーザーはオンラインで商品の支払いができる。 |
| 商品管理 | 希望 | 低 | 商品登録 | 管理者は新しい商品をシステムに登録できる。 |
| レポート機能 | 希望 | 低 | 売上レポート | 管理者は月間の売上レポートを閲覧できる。 |

**ユースケース図**

**フローチャート**

**概念データモデル**

**機能要件**

* ユーザー認証：
  + ユーザーはメールアドレスとパスワードを使用してログインできる。
  + 新規ユーザーはアカウント作成ページから登録できる。
* 商品検索機能：
  + ユーザーはキーワードやカテゴリーを使って商品を検索できる。
  + 検索結果はページに表示され、選択可能である。
* オンライン決済システム：
  + ユーザーはクレジットカードまたは電子決済システムを使用して支払いができる。
  + トランザクションは安全に処理される。
* 商品管理システム：
  + 管理者は新しい商品を登録し、既存の商品情報を編集できる。
* 販売レポート機能：
  + 管理者は月次、四半期ごとの売上レポートを生成し、分析できる。

**非機能要件**

* パフォーマンス：
  + システムは高速なレスポンス時間を保証し、ユーザーのリクエストには2秒以内に応答する。
* セキュリティ：
  + 全てのユーザーデータは暗号化され、不正アクセスから保護される。
* スケーラビリティ：
  + システムは高いトラフィックに対応し、簡単にスケーリングが可能。
  + バックアップとリカバリ：
  + データは定期的にバックアップされ、緊急時には迅速に復旧可能。
* ユーザビリティ：
  + インターフェースは直感的で、ユーザーフレンドリーである。

**スケジュール・費用**

総予算：約1000万円

### 6.要件の承認 💮

ステークホルダーと協力して要件をレビューし、承認を得ます。承認されない場合は、フィードバックを受けて要件を再検討します。

基本設計 🏛️
-------

要件定義の完了後、基本設計の段階に移行します。この段階では、システム開発の要件を具体化し、詳細設計や実装に向けた指針を確立します。

* Tips📝
  + 決定した理由や没になった案も含めて文書化し、将来の参照のために記録しておきます。

### 基本設計と詳細設計の違い

**基本設計**：システムがどのような機能や動作をすべきかを定め、**開発者が「何を開発すればよいか」を理解** するための指針を示します。この段階では実現方法の詳細には踏み込みません。

**詳細設計**：基本設計で定められた機能をプログラムコードに変換するための具体的な計画を立てます。プログラムの構造、インターフェース、データ構造を詳細に定義し、**同じ設計書から同様のプログラムが生まれる** ようにします。

### 基本設計成果物(架空のサンプル)

システムアーキテクチャ(架空のサンプル)
画面設計 (UI/UX設計)

* ワイヤーフレーム、モックアップ、プロトタイプなどを通じて、インターフェースのレイアウトと構造を示します。
* ユーザーフローダイアグラムやスタイルガイドを含む、UIの一貫性を保つためのガイドラインを作成します。

API設計(Swagger)

```
openapi: "3.0.0"
info:
  version: "1.0.0"
  title: "社内コミュニケーションポータルAPI"
  description: "社内コミュニケーションポータルのバックエンドAPI仕様"

paths:
  /users:
    get:
      summary: "ユーザーリストを取得"
      responses:
        '200':
          description: "ユーザーのリストを返す"
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'

  /users/{userId}:
    get:
      summary: "特定のユーザー情報を取得"
      parameters:
        - name: userId
          in: path
          required: true
          description: "ユーザーID"
          schema:
            type: string
      responses:
        '200':
          description: "指定されたユーザーの詳細情報"
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: "ユーザーが見つからない"

components:
  schemas:
    User:
      type: object
      required:
        - id
        - name
      properties:
        id:
          type: string
          description: "ユーザーID"
        name:
          type: string
          description: "ユーザー名"
        email:
          type: string
          description: "ユーザーのメールアドレス"
```

フローチャート図
ユースケース図
ER図

非機能要求グレード

非機能要求グレードのテーブル

| 単位 | 非機能要件カテゴリー | グレード1 | グレード2 | グレード3 |
| --- | --- | --- | --- | --- |
| API | **応答時間** | 平均3秒以内 | 平均1秒以内 | ピーク時でも500ms以内 |
|  | **メンテナンス性** | 基本的なドキュメント | 詳細ドキュメントとサポート | 継続的な更新とサポート |
|  | **セキュリティ** | 伝送中のデータ暗号化 | 伝送中・保存中のデータ暗号化 | 全データ暗号化に加え、詳細なアクセス制御と監査ログ |
|  | **可用性** | 99%アップタイム | 99.5%アップタイム | 99.9%アップタイム |
|  | **スケーラビリティ** | 手動スケールアップ | 自動スケーリング | 弾性的なリソース管理 |
|  | **システム容量** | 100ユーザー同時対応 | 500ユーザー同時対応 | 1000ユーザー以上同時対応 |
|  | **アクセス制御** | 基本認証 | 多要素認証 | ロールベースのアクセス制御と権限設定 |
|  | **互換性** | 基本的なプラットフォーム互換性 | 複数のデバイスサポート | クロスプラットフォーム対応 |
| 画面 | **アクセス制御** | 基本認証 | 多要素認証 | ロールベースのアクセス制御と権限設定 |
|  | **可用性** | 99%アップタイム | 99.5%アップタイム | 99.9%アップタイム |
|  | **スケーラビリティ** | 手動スケールアップ | 自動スケーリング | 弾性的なリソース管理 |
|  | **システム容量** | 100ユーザー同時対応 | 500ユーザー同時対応 | 1000ユーザー以上同時対応 |

リスク登録簿のテーブルサンプル

| リスクID | リスクの説明 | 発生確率 | 影響度 | 優先順位 | 緩和策 | 責任者 |
| --- | --- | --- | --- | --- | --- | --- |
| R1 | 技術的な制約による開発遅延 | 高 | 中 | 高 | 代替技術の検討 | 山田 太郎 |
| R2 | 要件の変更によるスコープの拡大 | 中 | 高 | 中 | 要件の変更管理プロセスの強化 | 田中 花子 |
| R3 | 予算超過 | 低 | 高 | 低 | 定期的な予算レビュー | 鈴木 一郎 |
| R4 | スタッフ不足によるリソースの制約 | 中 | 中 | 中 | 人員計画の見直し、アウトソーシング | 佐藤 次郎 |
| R5 | 未知の技術への依存 | 低 | 中 | 低 | 技術トレーニングとサポート体制の確立 | 伊藤 明子 |

詳細設計 🛠️
-------

基本設計の成果物を基に、詳細設計ではシステムの具体的な構造と動作を定め、**開発チームがソースコードを書くための指針** を提供します。

* ドキュメントの適応と更新：基本設計書で定義された機能を実際のコードに落とし込むため、必要に応じて修正や追加を行います。
* 共通の基準：**異なる開発者でも同様の結果を生み出せる** よう、プログラムの構造やインターフェース、データ構造を詳細に記載します。

### 詳細設計の必要性と例外

詳細設計はソフトウェア開発における重要な段階ですが、**すべてのプロジェクトで同じレベルの詳細化が必要というわけではありません**。

#### 詳細設計が不要とされるケース

* **アジャイル開発**
  + 詳細設計はアジャイル開発プロジェクトで最小限に留められることが多く、プロジェクトの進行に合わせて調整されることが一般的です。変更に柔軟に対応するため、詳細設計書の作成は省略されたり、簡素化されることがあります。
* **小規模プロジェクト**
  + 小規模チームや短期間のプロジェクトでは、詳細設計書の代わりに、基本設計とコード自体で十分なケースがあります。

#### DDDと詳細設計

DDDでは、設計はコード自体に統合されるため、従来の意味での詳細設計書の必要性が低減します。このアプローチでは、コードがビジネスロジックとドメインモデルを直接反映し、設計の詳細がコードに組み込まれます。そのため、詳細設計書は、コードの解説やビジネスルールの文脈での解釈に重点を置くことが一般的です。

### 開発スタイルによる影響

* **アジャイルやDDD**
  + これらのアプローチでは、設計はより動的であり、開発プロセスに統合されるため、詳細設計書の役割が変わります。特にDDDでは、コード自体がドメインモデルの表現となり、従来の詳細設計書のような別個の文書は必要最小限になります。
* **ウォーターフォールモデル**
  + この伝統的な開発モデルでは、詳細設計書がプロジェクトの初期段階で作成され、以降の開発工程で厳格に従われます。

### 詳細設計成果物(架空のサンプル)

クラス図
クラスとメソッドの定義/インターフェースの詳細化(ソフトウェア設計仕様書)

**クラス：User**

| 属性 | 型 | 説明 |
| --- | --- | --- |
| id | int | ユーザーのID |
| name | String | ユーザーの名前 |
| email | String | ユーザーのメール |

**メソッド：getUserById**

| メソッド名 | 引数 | 返り値 | 説明 |
| --- | --- | --- | --- |
| getUserById | id: int | User | IDに基づきユーザー情報を取得 |

**インターフェース：IUserRepository**

| メソッド名 | 引数 | 返り値 | 説明 |
| --- | --- | --- | --- |
| getUserById | id: int | User | IDに基づきユーザー情報を取得 |
| addUser | user: User | void | 新しいユーザーを追加 |
| deleteUser | id: int | void | IDに基づきユーザーを削除 |

シーケンス図
メソッドの仕様書

| 項目 | 説明 |
| --- | --- |
| **メソッド名** | calculateTotal |
| **目的** | 注文の合計金額を計算する |
| **引数** | items - List of Item: 購入する商品のリスト。各アイテムには価格と数量が含まれる |
| **返り値** | total - Decimal: 注文の合計金額 |
| **動作の説明** | 各アイテムの価格と数量を掛け合わせ、それらの合計を計算する |
| **副作用** | なし |
| **使用例** | `items = [Item(price=100, quantity=2), Item(price=200, quantity=1)]` `total = calculateTotal(items)` `print(total)` |
| **エラー処理** | 引数が空のリストの場合は0を返す |

#### 詳細なデータベース設計

詳細なデータベーススキーマ

#### テーブル：Users

| カラム名 | データ型 | 制約 | 説明 |
| --- | --- | --- | --- |
| UserID | INT | PRIMARY KEY, AUTO\_INCREMENT | ユーザーの一意のID |
| UserName | VARCHAR(50) | NOT NULL | ユーザー名 |
| Email | VARCHAR(50) | NOT NULL, UNIQUE | メールアドレス |
| Password | VARCHAR(50) | NOT NULL | パスワード |

#### テーブル：Products

| カラム名 | データ型 | 制約 | 説明 |
| --- | --- | --- | --- |
| ProductID | INT | PRIMARY KEY, AUTO\_INCREMENT | 商品の一意のID |
| Name | VARCHAR(100) | NOT NULL | 商品名 |
| Price | DECIMAL(10, 2) | NOT NULL | 価格 |
| Stock | INT | NOT NULL | 在庫数 |

#### テーブル：Orders

| カラム名 | データ型 | 制約 | 説明 |
| --- | --- | --- | --- |
| OrderID | INT | PRIMARY KEY, AUTO\_INCREMENT | 注文の一意のID |
| UserID | INT | FOREIGN KEY (UserID) | 注文したユーザーのID |
| OrderDate | DATE | NOT NULL | 注文日 |
| Total | DECIMAL(10, 2) | NOT NULL | 合計金額 |

#### テーブル：OrderDetails

| カラム名 | データ型 | 制約 | 説明 |
| --- | --- | --- | --- |
| OrderDetailID | INT | PRIMARY KEY, AUTO\_INCREMENT | 注文詳細の一意のID |
| OrderID | INT | FOREIGN KEY (OrderID) | 注文のID |
| ProductID | INT | FOREIGN KEY (ProductID) | 商品のID |
| Quantity | INT | NOT NULL | 数量 |
| Price | DECIMAL(10, 2) | NOT NULL | 価格 |

データベースの正規化レポート(書いたことないですが、こんなものもあるんですねー)

#### 1. 正規化の目的と背景

* **目的**：データの重複を排除し、更新時の異常を防ぎ、データ整合性を向上させる。
* **背景**：注文と商品情報が同じテーブルに存在し、データ更新時に冗長性と不整合の問題が発生していた。

#### 2. 正規化前のデータモデル

* **テーブル：OrderDetails**
  + Columns: OrderID, ProductName, ProductPrice, Quantity, TotalPrice
  + 問題点：同一商品の異なる注文でProductNameとProductPriceが繰り返し登録されていた。

#### 3. 正規化のプロセス

* **第1正規形（1NF）適用**
  + 各レコードがユニークなキー（OrderID）を持つようにする。
* **第2正規形（2NF）適用**
  + 注文情報と商品情報を分割し、OrderDetailsとProductsの2つのテーブルに分ける。

#### 4. 正規化後のデータモデル

* **テーブル：Orders**
  + Columns: OrderID, OrderDate, CustomerID
* **テーブル：OrderDetails**
  + Columns: OrderDetailID, OrderID, ProductID, Quantity
* **テーブル：Products**
  + Columns: ProductID, ProductName, ProductPrice
* これにより、商品情報の重複がなくなり、注文情報の更新が容易になった。

#### 5. 正規化の利点と影響

* **利点**：
  + データの整合性が向上。
  + 更新時の異常が減少。
  + クエリのパフォーマンス改善。
* **影響**：
  + クエリの書き方が変更され、JOINを多用する必要が出てきた。

#### 6. 具体的な例と図表

#### API仕様の詳細化

基本設計時に作成した API設計(Swagger) をさらに詳細化します。基本設計時に作成してなければこの段階で作成します。

* **パラメータの詳細化**
  + APIが受け取るパラメータのタイプ、フォーマット、バリデーション条件など定義。
* **エラーハンドリングの計画**
  + APIが返す可能性のあるエラーと、それらのステータスコードを定義します。

#### 画面設計の詳細化

* UIコンポーネントの詳細仕様
  + サイズ、色、配置などの具体的なデザイン要素を記載。
* ユーザーインタラクションの詳細

#### 非機能要求の具体的な実装基準

具体的な技術的仕様：システムアーキテクチャ、パフォーマンス基準、セキュリティプロトコルなどの非機能要求を具体化。

* データベースには⚪︎⚪︎⚪︎サービスを用いるとともに、データベースクエリの最適化を行い、レスポンス時間を1秒未満にする
* 特定の暗号化方式を用いてデータを保護する

#### リスク管理計画の更新と詳細化

リスク登録簿の更新：プロジェクトの進行に合わせて新たに明らかになったリスクを追加し、既存のリスクを再評価。

FAQ
---

こちらでは、ソフトウェア開発における気になってる疑問について生成AIに回答してもらいました。

### Q1: 技術検証はいつ行うのが最適ですか？

**A1:** 技術検証は、特に技術的なリスクが高い場合や新しい技術を導入する場合に重要です。要件定義の初期段階で行うことが望ましいです。これにより、リスクの早期発見、要件の正確な定義、プロジェクト計画の最適化が可能になります。ただし、プロジェクトの進行に合わせて技術検証を継続的に行うことも重要です。

### Q2: 新しい技術を使用する際の判断基準は何ですか？

**A2:** 新しい技術を採用するかどうかは、以下の要素を考慮して判断することが重要です：

* スケジュールの余裕があるか。
* チームのモチベーションやスキルセット。
* 技術の成熟度とプロジェクトのリスク許容度。
* 長期的なメンテナンスやスキルの継承が可能か。

### Q3: データベーススキーマはER図で代用できますか？

**A3:** ER図はデータの概念的モデルを示すために用いられ、データベーススキーマは物理的な実装の詳細を示します。理論上、ER図を詳細化してデータベーススキーマとして使用することは可能ですが、実務上は目的の違い、視覚的明瞭さの維持、実装の柔軟性の観点から、通常は別々に作成されます。

### Q4: 受託開発でも詳細設計を省略することはありますか？

**A4:** 受託開発においても、詳細設計の省略や簡素化は可能です。これはプロジェクトの規模、スケジュール、クライアントの要求、開発チームの作業スタイルに依存します。特にアジャイル方法論を採用している場合や、スピードを重視するプロジェクトでは、詳細設計の段階を簡略化することがあります。

### Q5: アジャイル開発での文書化はどのように行うべきですか？

**A5:** アジャイル開発では、文書化のプロセスは

柔軟かつ最小限に保たれます。重要なのは、プロジェクトの目標に必要な情報を提供することであり、詳細なドキュメントの作成に時間を費やすよりも、進行中のプロジェクトに適応し、必要に応じて文書を更新することが重視されます。

### Q6: ソフトウェア開発でのリスク管理はどのように行うべきですか？

**A6:** リスク管理は、プロジェクトの全期間を通じて行うべき重要なプロセスです。プロジェクトの初期段階でリスクの特定と評価を行い、緩和策を計画することが重要です。定期的なレビューとリスク評価の更新を通じて、新たに発生したリスクに対処し、プロジェクトの進捗に合わせてリスク管理計画を調整します。

### Q7: プロジェクトのスコープクリープを防ぐ方法は？

**A7:** スコープクリープを防ぐためには、明確な要件定義、効果的なステークホルダーの関与、および変更管理プロセスの確立が必要です。また、定期的なプロジェクトのレビューを行い、新たな要望や提案がプロジェクトの目標と合致するかどうかを評価することも重要です。

### Q8: プロジェクトの遅延を避けるためのベストプラクティスは？

**A8:** プロジェクトの遅延を避けるためには、現実的なスケジュールの設定、タスクの優先順位付け、リソースの適切な管理、および進捗の定期的な監視が必要です。また、リスク管理計画を立て、予期しない問題への対応策を準備しておくことも効果的です。

まとめ
---

この記事では、開発プロセスの基本設計から詳細設計に至るまでを、体系的に整理し復習してきました。  
このプロセスを通じて、これまでの経験を頭の中を整理することができた気がします！！

実際のプロジェクトでは、要件定義から基本設計まで、いつもこんなに細かくやるわけではないですが、  
プロジェクト毎のニーズに合わせて、必要なポイントだけをピックアップして進めるのが良いかなと思います。
